# 프로젝트 이름

Book Binder application

# 프로젝트 소개

도서 관리자를 위한 도서 관리 애플리케이션 입니다. 해당 애플리케이션을 통해 현재 보유 중인 책들을 관리할 수 있으며, 새로 입고 된 책들을 추가할 수 있고, 수정되어야 할 정보들이 있다면 수정이 가능하고, 더 이상 존재하지 않는 책들은 제거할 수 있습니다.

현재 책의 종류를 구분하는 가장 큰 카테고리로는 인문학(Humanities), 자연과학(Natural Sciences), 역사 (History), 픽션 (Fiction)이 존재하는데, 향후에 다양한 책이 추가됨으로써 큰 카테고리 또한 다양해 질 것을 염두하여 테이블 구조를 계층적 테이블 구조로 구성하였습니다. 계층적으로 테이블을 구성함으로써 큰 카테고리가 추가 될 때마다 번거롭게 새로운 테이블을 수동적으로 생성 할 필요 없도록 하였습니다.

정리하자면, 해당 어플리케이션을 통해 도서 관리자는 다음과 같은 효과를 얻을 수 있습니다.

-효율성: 도서 정보 불러오기, 추가, 삭제, 수정 등의 작업을 한 곳에서 할 수 있어 작업 효율성이 향상됩니다.

-시간 절약: 간편한 검색 기능을 통해 일정한 조건에 해당하는 책 정보를 빠르게 찾을 수 있습니다. 이는 도서 관리에 소요되는 시간을 크게 줄여줍니다.

-유지보수성: 새로운 카테고리가 생성될 때마다 번거롭게 테이블을 수동적으로 생성할 필요가 없습니다.

(현재 DB의 테이블 구조는 계층적 테이블 구조를 이루고 있기 때문에, 큰 카테고리 항목이 추가될 때마다 번거롭게 테이블을 수동적으로 생성 할 필요 없이, 카테고리 이름을 입력하면 상위 테이블에 해당 카테고리의 레코드가 생성이 되고 이 레코드를 기반으로 하위 테이블에서는 그 카테고리 범주에 해당되는 책의 정보들이 들어가게 됩니다.)

# 프로젝트 실행 방법

1. 환경 설정: 먼저 .env 파일에 필요한 환경 변수들을 설정해야 합니다. 여기서 <Your Password>는 실제 MySQL 비밀번호로 교체해야 합니다.

2. 서버 실행: 먼저 프로젝트 루트 폴더에서 server 폴더로 이동합니다. 이동한 후에 npm start 명령어를 입력하면 서버가 시작되고 데이터베이스와의 연결이 초기화됩니다.

```bash

cd server
npm start

```

3. API 테스트: 서버가 정상적으로 실행되면 Postman과 같은 API 테스트 도구를 사용해서 각 API의 동작을 확인할 수 있습니다. 이 테스트는 서버가 클라이언트의 요청을 올바르게 처리하고 응답하는지를 확인할 수 있습니다. API 관련 문서는 아래의 '더 알아보기'를 참고해주세요.

> 참고: 이 프로젝트를 실행하기 위해서는 Node.js가 설치되어 있어야 합니다. 또한, 프로젝트를 처음 실행하는 경우 npm install 명령어를 통해 필요한 패키지들을 설치해야 합니다.

# 프로젝트 구조 및 파일 설명

## 1. 디렉토리 구조

- `/server` : 서버 애플리케이션 코드가 있는 디렉토리입니다.

## 2. 서버 디렉토리 구조

서버의 코드는 MVC 패턴에 따라 구조화되어 있습니다.

- `/server`
  - `app.js`: 서버 애플리케이션의 진입점입니다. 서버를 시작하고, 필요한 미들웨어를 설정하며, 라우트를 설정합니다.
  - `config.js`: 환경 변수 및 설정 값들을 관리하는 파일입니다.
  - `.env`: 비공개 환경 변수를 저장하는 파일입니다. 이 파일은 git에 올리지 않아야 합니다.
  - `.gitignore`: git이 추적하지 않아야 하는 파일 및 디렉토리를 명시하는 파일입니다.
  - `package.json`: 프로젝트에 대한 메타데이터와 사용하는 패키지를 나열하는 파일입니다.
  - `/controller`
    - `product.js`: 책 관련 요청 처리 로직이 구현된 컨트롤러 파일입니다.
  - `/data`
    - `product.js`: 책 데이터에 대한 모델 파일입니다. 이 파일은 데이터베이스에서 책의 데이터를 조회하거나 저장하는 데 사용됩니다.
  - `/db`
    - `database.js`: 데이터베이스 연결 및 초기화 관련 코드가 있는 파일입니다.
  - `/router`
    - `product.js`: 책 관련 라우팅을 관리하는 파일입니다. 이 파일은 책 관련 요청을 적절한 컨트롤러 메서드에 연결합니다.

# 기술 스택

## 서버

- Node.js: 서버 사이드 JavaScript 실행 환경
- Express.js: 웹 애플리케이션 프레임워크
- MySQL: 관계형 데이터베이스 시스템
- dotenv: 환경 변수를 .env 파일에서 프로세스의 환경 변수로 로드
- express-async-errors: Express 라우트와 미들웨어 내에서 비동기 오류를 처리
- Helmet: HTTP 헤더 설정을 통해 애플리케이션 보안을 강화하는 미들웨어
- Morgan: HTTP 요청 로거 미들웨어
- CORS: Cross-Origin Resource Sharing (CORS)을 가능하게 하는 미들웨어
- Nodemon: Node.js 애플리케이션의 개발을 단순화하는 도구 (개발 모드로 설치)

# Base URL

모든 API 요청은 다음 base URL을 사용합니다: `http://localhost:3000`.

# API 개요

## 1. 모든 책들을 가져오기

- `GET /books`: 데이터베이스의 모든 책들의 정보와 총 개수를 가져옵니다.
- 주의: 데이터베이스는 초기에 비어 있습니다. 이 API를 사용하기 전에 POST 요청을 통해 상품을 먼저 추가해야 합니다. 상세한 방법은 '8번 패션 상품 추가하기 API'를 참조해주세요.

## 2. 특정 카테고리별로 이에 해당하는 모든 책들을 가져오기

- `GET /books/category/:categoryName`: 데이터베이스에 존재하는 카테고리별로 모든 책들의 정보와 총 개수를 가져옵니다.

## 3. 책 이름을 통해 해당 책의 정보 가져오기

- `GET /books/bookName/:name`: 데이터베이스에서 특정 책에 대한 정보를 가져옵니다.

## 4. 출판사 별로 책들의 정보 불러오기

- `GET /books/publisher/:name`: 특정 출판사의 모든 책 정보와 총 개수를 가져옵니다.

## 5. 특정 카테고리별 총 판매량 가져오기

- `GET /books/sales/:categoryName`: 특정 카테고리에 해당하는 모든 책들의 총 판매량을 가져옵니다.

## 6. 특정 카테고리별 총 재고 수량 가져오기

- `GET /books/totalStock/:categoryName`: 특정 카테고리에 해당하는 모든 책들의 총 재고 수량을 가져옵니다.

## 7. 판매량 상위 3개 책들을 가져오기

- `GET /books/bestsellers`: 모든 책들을 통틀어서 가장 판매량이 높은 상위 3개의 책들의 정보를 가져옵니다.

## 8. 책 정보 추가하기

- `POST /books`: 데이터베이스에 책의 정보를 추가합니다.

## 9. 특정 책의 판매량 수정하기

- `PUT /books/updateSales/:bookName/:publicationYear`: 데이베이스에 있는 특정 책의 판매량을 수정합니다.

## 10. 특정 책의 재고 수량 수정하기

- `PUT /books/updateStock/:bookName/:publicationYear`: 데이베이스에 있는 특정 책의 재고 수량을 수정합니다.

## 11. 특정 책의 정보를 삭제하기

- `DELETE /books/delete/:bookName/:publicationYear`: 데이베이스에 있는 특정 책의 정보를 삭제합니다.

## 더 알아보기

더 자세한 API 정보는 [https://documenter.getpostman.com/view/24146598/2s946maqCt]의 Postman API 문서를 참고해주세요.

# 데이터베이스 설계와 이유

데이터베이스는 카테고리 테이블과 북 테이블로 구성되어 있습니다.

카테고리 테이블은 북 테이블의 상위 테이블로, 다양한 종류의 책 카테고리를 담당하고 있습니다. 각 책은 이 카테고리 테이블로부터 카테고리 ID를 참조하여 어떤 카테고리에 속하는지를 식별합니다.

이런 계층적인 구조를 다음과 같은 이유로 선택하였습니다.

-데이터 중복 최소화: 카테고리 정보를 각 책 레코드에 반복해서 저장하는 대신, 한 번만 저장하고 다른 테이블에서 참조함으로써 중복을 피하고 데이터 관리를 간편하게 합니다.

-데이터 일관성 유지: 만일 카테고리가 변경되거나 추가되는 경우, 한 곳에서만 수정하면 되므로 데이터 일관성을 유지할 수 있습니다.

-데이터 확장성 보장: 새로운 카테고리가 생성되더라도, 이를 위해 새로운 테이블을 만들 필요가 없습니다. 단순히 카테고리 테이블에 새로운 카테고리를 추가하기만 하면 됩니다. 이는 확장성을 크게 높여줍니다.

-데이터 효율성 증대: 책의 수량, 판매량 등 책에 관련된 정보와 카테고리에 관련된 정보는 서로 분리되어 있기 때문에, 필요한 정보만을 검색하거나 수정하는 등의 작업이 더 효율적이게 됩니다.

북 테이블은 책의 제목, 저자, 출판연도, 출판사, 판매량, 재고량 등의 정보를 포함하고 있으며, 각 책 레코드는 상위 카테고리 테이블에 의해 분류됩니다. 또한, 북 테이블의 각 레코드는 생성 시간과 업데이트 시간을 기록함으로써 데이터 관리에 효율성을 더하도록 하였습니다.

# 오류 발생 및 문제 해결 과정

이미 SNS 어플리케이션을 만들어 본 경험이 있기 때문에 이번 프로젝트를 진행하면서 코드를 작성해나가는 과정에서 큰 어려움은 없었고, 큰 오류를 경험하지는 못 했습니다.

다만, 데이터베이스 모델링을 스스로 하는 과정은 처음 해보는 것이었기에 처음에는 이를 어떤 식으로 모델링 할지에 대해서 많이 고민을 하였습니다. 개인적으로 요즘 DB 관련 공부를 하면서 데이터베이스 모델링이라는 개념에 대해서 공부를 하고 있었기에 ERD까지 그려본 것은 아니지만 ERD가 존재하는 목적을 생각해보면서 테이블을 구성해보려고 노력하였습니다.

처음에는 하나의 테이블에 모든 책의 정보들이 저장되도록 구현을 했습니다. 하지만 향후에 특정 카테고리의 이름이 바뀌었을 때 이 카테고리에 해당하는 모든 데이터를 일일이 찾아서 수정을 해줘야 한다는 것을 발견하게 되었고, 특정 카테고리의 책들의 정보를 검색했을 때 불필요하게 테이블의 모든 레코드를 확인해야 한다는 점 때문에 이를 해결 할 방법을 찾아보게 되었습니다.

결과적으로 계층형으로 테이블을 분리함으로써 위의 2가지 문제를 해결할 수 있었습니다.

그리고 현재 어플리케이션의 모든 API들은 하나의 라우터 파일 안에 작성이 되었습니다. 처음에는 라우터를 2개로 나눠서 작성을 할 생각이었지만, API들을 만들기 위해 작성한 코드 로직이 서로 크게 다르지 않기 때문에 2개를 나눠서 작성하기 보다는 하나의 라우터 안에서 관리를 하는게 유지 보수를 하는데 있어서 더 효율적이라 판단하였습니다. 향후에 로그인과 같은 아예 다른 기능을 구현해야 한다면 이는 따로 라우터를 생성하여 만들 예정입니다.

그 외에 코드를 작성하면서 작은 오류들이 있었는데, 이는 터미널에 출력되는 오류 메세지를 보면서 해결하였습니다.

# 프로젝트를 진행하면서 느낀 점 및 후기

이번 프로젝트를 하면서 정말 배운게 많았습니다. 저는 기존에 SNS 어플리케이션을 만들어 본 경험이 있고 이는 강의를 통해 진행했기에 온전히 제 것으로 만들기 위해 처음부터 끝까지 스스로 만들어보는 과정 또한 진행했었지만, 어플리케이션의 결과가 정해진 상태에서 만들어보는 것과 이번에 진행했던 프로젝트처럼 결과가 정해져 있지 않고 정말 스스로 조건들에 대해서 만들어보는 경험은 처음이었습니다.

- 깃 관련된 내용을 정말 많이 배웠습니다. 커밋 메세지를 길게 남기는 방법, 직전 커밋 메세지를 수정하는 방법 등을 배웠습니다. 그리고 merge를 실제로 해본적이 없었는데, 이번에 시도해봤고 성공적으로 잘 되어서 많은 보람을 느꼈습니다. 그리고 처음에 노드모듈을 gitignore 파일에 포함 시켰다고 생각했는데 이미 git에 추가가 된 이후여서 이를 삭제하여 더이상 git에서 추적하지 않도록 설정하는 방법을 배울 수 있었습니다.

- id라는 기본키를 설정하는데 있어서 자연키 보다는 인조키를 사용하는게 더 좋은데 인조키를 사용하면 데이터가 중복될 우려가 있기에 향후 문제가 생길 여지가 있기 때문이다. 라는 것을 배웠습니다.

이 외에도 기본적으로 알고 있어야 하는 내용들에 대해서 정말 많은 것들을 배울 수 있었습니다. 예를 들어 controller에서 함수를 작성할 때 매개변수로 req와 res를 받는데, 저는 처음에 req를 사용하지 않는 함수에는 req을 따로 매개변수로 작성하지 않아도 된다고 생각했습니다. 하지만 향후 이로 인한 오류가 발생하였고 req를 사용하지 않더라도 작성을 해줘야 한다는 것을 알게 되었습니다.

그리고 프로젝트를 만드는데 있어서 주어진 조건들 외에 스스로 판단하여 추가한 기능들에 대해서 설명을 드리겠습니다.

- Cors 기능 추가: 어플리케이션을 운영하는데 있어서 필수로 들어가야 할 항목입니다. IP가 다르면 서로 통신을 못 하는게 원칙이지만, cors를 통해 IP가 다르더라도 서로 통신을 할 수 있게 해주는데, 만약 모든 IP들에 대해서 요청을 받아들이도록 설정을 한다면 엄청난 문제를 초래할 것입니다. 그렇기에 cors에 요청을 받을 URL을 적어줌으로써 정해진 클라이언트에게만 요청을 받도록 하였습니다.

- Helmet 라이브러리 추가: 보안을 한층 더 향상시켜주는 라이브러리 입니다. 패키지를 다운 받은 뒤에 import 하여 선언만 해줘도 사용 가능하기에 매우 편리합니다.

- morgan 라이브러리 추가: 서버에게 들어오는 요청에 대한 내용을 터미널에 로그를 남겨주는 로깅 모듈입니다. 이 외에도 여러가지 로그 기록을 파악할 수 있기에 디버깅이나 유지보수 하는데 있어서 장점이 됩니다.

- 환경 변수 설정: dotenv 모듈을 사용하여 환경변수를 설정하였습니다. 이는 config.js와 .env에 작성하였는데, 환경 변수를 설정함으로써 개발 단계에서 예기치 못한 오타로 인한 오류를 방지할 수도 있고, 개인적인 정보나 중요한 정보들을 은닉할 수 있기에 보안적인 부분에서도 효과를 얻을 수 있습니다.

- express-async-errors 비동기 오류 처리 미들웨어: 비동기 코드, 동기 코드의 각자의 성격에 따라 오류 코드를 작성을 해줘야 합니다. 하지만 이 미들웨어를 통해서 오류 처리 미들웨어로 모든 오류들을 전달하도록 할 수 있습니다.

- MVC 패턴: MVC 패턴으로 나누어서 서버 코드를 구성하게 된다면 각자의 역할이 명확하게 보이기에 가독성이 좋고 향후 코드의 변경이 있더라도 상대적으로 작은 부분만 수정하면 되기에 유지보수성에서도 큰 장점이 있습니다.

- DB 연결 후 server 실행: app.js에서 DB 초기화 작업을 통해 테이블이 전부 잘 생성되고 정상적으로 DB에 연결이 된 뒤에 서버가 실행되도록 하였습니다. 이렇게 하면 DB가 온전히 생성되었다는 것을 보장 받은 상태에서 서버가 동작하기에 안정성이 확보됩니다.

# 향후 구현하고 싶은 기능들

- express-async-errors 모듈을 사용했더라도 컨트롤러에 있는 함수들마다 각자의 오류 메세지를 생성할 예정입니다.

- POST를 하는데 있어서 중복된 데이터가 들어오지 못하도록 유효성 검사 기능을 추가할 예정입니다.

- 조금 더 실제 애플리케이션과 비슷하게 만들기 위해 출판 연도 별로 데이터를 불러오는 API를 추가할 예정입니다.

- Sequelize ORM을 사용해서 조금 더 완성도 높은 애플리케이션을 만들어 볼 예정입니다.
